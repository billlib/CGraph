<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGraph: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGraph
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<p><a href="inherits.html">Go to the graphical class hierarchy</a></p>
This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span><span onclick="javascript:toggleLevel(4);">4</span><span onclick="javascript:toggleLevel(5);">5</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_c_allocator.html" target="_self">CAllocator</a></td><td class="desc"></td></tr>
<tr id="row_1_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_1_" class="arrow" onclick="toggleFolder('1_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_c_desc_info.html" target="_self">CDescInfo</a></td><td class="desc"></td></tr>
<tr id="row_1_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_0_" class="arrow" onclick="toggleFolder('1_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_aspect_object.html" target="_self">GAspectObject</a></td><td class="desc">在GraphObject和CDescInfo的基础上新增私有成员param_manager_/event_manager_/param_/belong_ param_manager_/event_manager_用于引入GParamManager和GEventManager param_用于引入GPassedParam，对于GAspectObject来说是GAspectParam belong_则是GAspectObject独有的，维护切面和GElement的从属关系 </td></tr>
<tr id="row_1_0_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_0_0_" class="arrow" onclick="toggleFolder('1_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_aspect.html" target="_self">GAspect</a></td><td class="desc"></td></tr>
<tr id="row_1_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_1_0_0_0_" class="arrow" onclick="toggleFolder('1_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_template_aspect.html" target="_self">GTemplateAspect&lt; Args ... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_perf_aspect.html" target="_self">GPerfAspect&lt; Args &gt;</a></td><td class="desc">预先写好的用于做性能分析的切面 </td></tr>
<tr id="row_1_0_0_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_template_aspect.html" target="_self">GTemplateAspect&lt; Args &gt;</a></td><td class="desc"><a class="el" href="class_g_template_aspect.html" title="GTemplateAspect(空) = GAspect，但是实现成模板类，可以自己用模板参数加以实现">GTemplateAspect</a>(空) = GAspect，但是实现成模板类，可以自己用模板参数加以实现 </td></tr>
<tr id="row_1_0_0_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_switch_g_aspect.html" target="_self">SwitchGAspect</a></td><td class="desc"></td></tr>
<tr id="row_1_0_1_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_aspect_manager.html" target="_self">GAspectManager</a></td><td class="desc"></td></tr>
<tr id="row_1_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_1_" class="arrow" onclick="toggleFolder('1_1_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_daemon_object.html" target="_self">GDaemonObject</a></td><td class="desc">在GraphObject和CDescInfo的基础上新增私有成员param_manager_/event_manager_/param_/interval_ param_manager_/event_manager_用于引入GParamManager和GEventManager param_用于引入GPassedParam，对于GDaemonObject来说是GDaemonParam interval_则是GDaemonObject独有的，维护定时器的执行周期 </td></tr>
<tr id="row_1_1_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_1_0_" class="arrow" onclick="toggleFolder('1_1_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_daemon.html" target="_self">GDaemon</a></td><td class="desc"></td></tr>
<tr id="row_1_1_0_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_camera_g_daemon.html" target="_self">CameraGDaemon</a></td><td class="desc"></td></tr>
<tr id="row_1_1_0_1_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_template_daemon.html" target="_self">GTemplateDaemon&lt; Args &gt;</a></td><td class="desc"><a class="el" href="class_g_template_daemon.html" title="GTemplateDaemon(空) = GDaemon，但是实现成模板类，可以自己用模板参数加以实现">GTemplateDaemon</a>(空) = GDaemon，但是实现成模板类，可以自己用模板参数加以实现 </td></tr>
<tr id="row_1_1_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_daemon_manager.html" target="_self">GDaemonManager</a></td><td class="desc">维护GDaemon实例的集合daemons_ 支持批量init/批量destroy，在daemons_里面add/destroy或者清空daemons_等 </td></tr>
<tr id="row_1_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_2_" class="arrow" onclick="toggleFolder('1_2_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element.html" target="_self">GElement</a></td><td class="desc">CGraph所有广义"结点"的基类，可派生出GNode/GGroup/GAdapter类 public: 提供addGAspect加入切面/addDependGElement加入前序依赖/removeDepend删除前序依赖的能力 提供setName更新名称/setLoop设置循环次数/setLevel设置优先级/setVisible隐藏当前元素/setBindingIndex设置亲和线程等能力 提供setTimeout设置元素执行的超时时间/setMacro设置为微任务的能力 提供addEParam添加GElement内部参数(GElementParam，实际上就是GPassedParam) 还额外提供运算符重载：&ndash;(setVisible)、&gt;(设置后继依赖)、&amp;(设置后继依赖)、*(setLoop) </td></tr>
<tr id="row_1_2_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_2_0_" class="arrow" onclick="toggleFolder('1_2_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_adapter.html" target="_self">GAdapter</a></td><td class="desc"></td></tr>
<tr id="row_1_2_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_coordinator.html" target="_self">GCoordinator&lt; SIZE &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_2_0_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_fence.html" target="_self">GFence</a></td><td class="desc">默认的前序后继方式只能等待有连接关系的结点 GFence用于在没有依赖关系的情况下，强行等待一个或一组异步结点的运行结束 </td></tr>
<tr id="row_1_2_0_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_function.html" target="_self">GFunction</a></td><td class="desc">将一个函数注入成一个GElement，函数可以注入为这个新的GElement的init/run/destroy </td></tr>
<tr id="row_1_2_0_3_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_singleton.html" target="_self">GSingleton&lt; T &gt;</a></td><td class="desc">GAdapter的派生类，核心成员是static USingleton&lt;T&gt; s_singleton单例，可以方便地作为单例GElement使用 </td></tr>
<tr id="row_1_2_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_2_1_" class="arrow" onclick="toggleFolder('1_2_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_group.html" target="_self">GGroup</a></td><td class="desc">所有节点组合的基类，所有节点组合功能，均继承自此类 </td></tr>
<tr id="row_1_2_1_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_cluster.html" target="_self">GCluster</a></td><td class="desc"></td></tr>
<tr id="row_1_2_1_1_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_1_2_1_1_" class="arrow" onclick="toggleFolder('1_2_1_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_condition.html" target="_self">GCondition</a></td><td class="desc"></td></tr>
<tr id="row_1_2_1_1_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_multi_condition.html" target="_self">GMultiCondition&lt; type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_2_1_2_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_mutable.html" target="_self">GMutable</a></td><td class="desc">常规的GGroup及其派生类在运行时是不允许再修改前序后继关系的，但是GMutable可以 具体做法是GMutable在每次run的时候会先调用setup初始化自己这张子图(实际上就是清空)，再调用reshape修改前序后继关系，最后才是正常运行子图 GMutable的reshape是纯虚函数，派生类必须实现，可以参考MyMutable示例 </td></tr>
<tr id="row_1_2_1_3_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_region.html" target="_self">GRegion</a></td><td class="desc">多个Element的集合，一般非纯并行、也非纯串行(Gluster)时使用 </td></tr>
<tr id="row_1_2_1_4_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_some.html" target="_self">GSome&lt; TriggerNum &gt;</a></td><td class="desc">对于插入的所有GElement，不管实际能不能并行，GSome都会把这些GElement提交到异步任务里面全并发执行(详见run) TriggerNum个GElement执行完成后就退出不再执行剩余的，剩余的置为TIMEOUT(在GElement的fatProcessor里面会不执行直接结束) </td></tr>
<tr id="row_1_2_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_2_2_" class="arrow" onclick="toggleFolder('1_2_2_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_node.html" target="_self">GNode</a></td><td class="desc">功能运行的最小单元(结点) </td></tr>
<tr id="row_1_2_2_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_action_g_node.html" target="_self">ActionGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_car_detector_g_node.html" target="_self">CarDetectorGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_d_ann_node.html" target="_self">DAnnNode</a></td><td class="desc">ANN领域算子模型抽象，说人话，就是抽象了一套跑NN相关的范式 prepareParam准备要接下来要run的函数类型 函数类型和DAnnNode的成员函数一一对应，分别有 train/search/insert/update/remove/loadModel/saveModel/edition； 上述接口在DAnnNode这个基类都为空，由派生类自行实现，在run统一调用； </td></tr>
<tr id="row_1_2_2_3_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_template_node.html" target="_self">GTemplateNode&lt; Args &gt;</a></td><td class="desc"><a class="el" href="class_g_template_node.html" title="GTemplateNode(空) = GNode，但是实现成模板类，可以自己用模板参数加以实现">GTemplateNode</a>(空) = GNode，但是实现成模板类，可以自己用模板参数加以实现 </td></tr>
<tr id="row_1_2_2_4_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_generate_g_node.html" target="_self">GenerateGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_5_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_input_g_node.html" target="_self">InputGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_6_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_lane_detector_g_node.html" target="_self">LaneDetectorGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_7_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_map_g_node.html" target="_self">MapGNode&lt; MAP_TAG &gt;</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_8_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_process_g_node.html" target="_self">ProcessGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_9_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_reduce_g_node.html" target="_self">ReduceGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_10_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_result_g_node.html" target="_self">ResultGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_2_2_11_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_show_g_node.html" target="_self">ShowGNode</a></td><td class="desc"></td></tr>
<tr id="row_1_3_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_1_3_" class="arrow" onclick="toggleFolder('1_3_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_event_object.html" target="_self">GEventObject</a></td><td class="desc"></td></tr>
<tr id="row_1_3_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_1_3_0_" class="arrow" onclick="toggleFolder('1_3_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_event.html" target="_self">GEvent</a></td><td class="desc">事件机制，addGEvent将事件注册到pipeline notify触发，process处理信号，trigger同步执行，asyncProcess异步执行，asyncWait等待异步任务结束 </td></tr>
<tr id="row_1_3_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_show_g_event.html" target="_self">ShowGEvent</a></td><td class="desc"></td></tr>
<tr id="row_1_3_1_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_event_manager.html" target="_self">GEventManager</a></td><td class="desc"></td></tr>
<tr id="row_1_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline.html" target="_self">GPipeline</a></td><td class="desc"></td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_2_" class="arrow" onclick="toggleFolder('2_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_c_object.html" target="_self">CObject</a></td><td class="desc"></td></tr>
<tr id="row_2_0_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_0_" class="arrow" onclick="toggleFolder('2_0_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GStage &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_0_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_stage_manager.html" target="_self">GStageManager</a></td><td class="desc"></td></tr>
<tr id="row_2_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_1_" class="arrow" onclick="toggleFolder('2_1_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GElement &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_1_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element_manager.html" target="_self">GElementManager</a></td><td class="desc"></td></tr>
<tr id="row_2_2_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_2_" class="arrow" onclick="toggleFolder('2_2_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GEvent &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_2_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_event_manager.html" target="_self">GEventManager</a></td><td class="desc"></td></tr>
<tr id="row_2_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_3_" class="arrow" onclick="toggleFolder('2_3_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GDaemon &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_3_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_daemon_manager.html" target="_self">GDaemonManager</a></td><td class="desc">维护GDaemon实例的集合daemons_ 支持批量init/批量destroy，在daemons_里面add/destroy或者清空daemons_等 </td></tr>
<tr id="row_2_4_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_4_" class="arrow" onclick="toggleFolder('2_4_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GParam &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_4_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_param_manager.html" target="_self">GParamManager</a></td><td class="desc"></td></tr>
<tr id="row_2_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_5_" class="arrow" onclick="toggleFolder('2_5_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GMessage&lt; GMessageParam &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_5_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message_manager.html" target="_self">GMessageManager&lt; T, &gt;</a></td><td class="desc">基于topic，支持send/recv(一发一收)，也支持pub/sub(一发多收) sub端每次订阅特定的topic之前都要先bindTopic生成一个唯一的conn_id_，实际上是绑定到这个conn_id_对应的GMessageObject的消息队列 recv是一发一收则可以直接用topic作为入参 </td></tr>
<tr id="row_2_6_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_6_" class="arrow" onclick="toggleFolder('2_6_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GAspect &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_6_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_aspect_manager.html" target="_self">GAspectManager</a></td><td class="desc"></td></tr>
<tr id="row_2_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_7_" class="arrow" onclick="toggleFolder('2_7_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; GPipeline &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_7_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline_manager.html" target="_self">GPipelineManager</a></td><td class="desc"></td></tr>
<tr id="row_2_8_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_8_" class="arrow" onclick="toggleFolder('2_8_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_domain_object.html" target="_self">DomainObject</a></td><td class="desc"><a class="el" href="class_d_ann_object.html" title="DAnnObject = DomainObject, run设置为CGRAPH_NO_SUPPORT.">DAnnObject</a> = <a class="el" href="class_c_object.html">CObject</a> </td></tr>
<tr id="row_2_8_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_8_0_" class="arrow" onclick="toggleFolder('2_8_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_d_ann_object.html" target="_self">DAnnObject</a></td><td class="desc"><a class="el" href="class_d_ann_object.html" title="DAnnObject = DomainObject, run设置为CGRAPH_NO_SUPPORT.">DAnnObject</a> = <a class="el" href="class_domain_object.html" title="DAnnObject = CObject.">DomainObject</a>, run设置为CGRAPH_NO_SUPPORT </td></tr>
<tr id="row_2_8_0_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_d_ann_node.html" target="_self">DAnnNode</a></td><td class="desc">ANN领域算子模型抽象，说人话，就是抽象了一套跑NN相关的范式 prepareParam准备要接下来要run的函数类型 函数类型和DAnnNode的成员函数一一对应，分别有 train/search/insert/update/remove/loadModel/saveModel/edition； 上述接口在DAnnNode这个基类都为空，由派生类自行实现，在run统一调用； </td></tr>
<tr id="row_2_8_0_1_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_d_ann_param.html" target="_self">DAnnParam</a></td><td class="desc"></td></tr>
<tr id="row_2_9_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_manager.html" target="_self">GraphManager&lt; T, &gt;</a></td><td class="desc">所有以GraphObject为基类的对象（GAsepct/GDaemon/GEvent/GElement/GPipeline/GParam）的管理器的基类 </td></tr>
<tr id="row_2_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_10_" class="arrow" onclick="toggleFolder('2_10_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_graph_object.html" target="_self">GraphObject</a></td><td class="desc"><a class="el" href="class_graph_object.html" title="GraphObject = CObject，没有新增或删除任何成员">GraphObject</a> = CObject，没有新增或删除任何成员 </td></tr>
<tr id="row_2_10_0_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_aspect_object.html" target="_self">GAspectObject</a></td><td class="desc">在GraphObject和CDescInfo的基础上新增私有成员param_manager_/event_manager_/param_/belong_ param_manager_/event_manager_用于引入GParamManager和GEventManager param_用于引入GPassedParam，对于GAspectObject来说是GAspectParam belong_则是GAspectObject独有的，维护切面和GElement的从属关系 </td></tr>
<tr id="row_2_10_1_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_daemon_object.html" target="_self">GDaemonObject</a></td><td class="desc">在GraphObject和CDescInfo的基础上新增私有成员param_manager_/event_manager_/param_/interval_ param_manager_/event_manager_用于引入GParamManager和GEventManager param_用于引入GPassedParam，对于GDaemonObject来说是GDaemonParam interval_则是GDaemonObject独有的，维护定时器的执行周期 </td></tr>
<tr id="row_2_10_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_10_2_" class="arrow" onclick="toggleFolder('2_10_2_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element_object.html" target="_self">GElementObject</a></td><td class="desc"><a class="el" href="class_g_element_object.html" title="GElementObject = GraphObject = CObject，没有新增或删除任何成员">GElementObject</a> = <a class="el" href="class_graph_object.html" title="GraphObject = CObject，没有新增或删除任何成员">GraphObject</a> = CObject，没有新增或删除任何成员 </td></tr>
<tr id="row_2_10_2_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element.html" target="_self">GElement</a></td><td class="desc">CGraph所有广义"结点"的基类，可派生出GNode/GGroup/GAdapter类 public: 提供addGAspect加入切面/addDependGElement加入前序依赖/removeDepend删除前序依赖的能力 提供setName更新名称/setLoop设置循环次数/setLevel设置优先级/setVisible隐藏当前元素/setBindingIndex设置亲和线程等能力 提供setTimeout设置元素执行的超时时间/setMacro设置为微任务的能力 提供addEParam添加GElement内部参数(GElementParam，实际上就是GPassedParam) 还额外提供运算符重载：&ndash;(setVisible)、&gt;(设置后继依赖)、&amp;(设置后继依赖)、*(setLoop) </td></tr>
<tr id="row_2_10_2_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element_manager.html" target="_self">GElementManager</a></td><td class="desc"></td></tr>
<tr id="row_2_10_2_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element_repository.html" target="_self">GElementRepository</a></td><td class="desc"></td></tr>
<tr id="row_2_10_2_3_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_10_2_3_" class="arrow" onclick="toggleFolder('2_10_2_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_engine.html" target="_self">GEngine</a></td><td class="desc">CGraph的核心引擎，提供setup/link/getTopo/isDag等核心能力 </td></tr>
<tr id="row_2_10_2_3_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_dynamic_engine.html" target="_self">GDynamicEngine</a></td><td class="desc">CGraph的核心引擎，提供DAG类型分析、拓扑分析、动态图运行、全并发执行、全串行执行等能力 </td></tr>
<tr id="row_2_10_2_3_1_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_static_engine.html" target="_self">GStaticEngine</a></td><td class="desc">将待执行的图中的所有结点进行拓扑排序(setup)，排序结果存储在element_mat_； 然后将element_mat_各个拓扑排序好的结点提交到微线程或者线程池，等待执行完成获取结果(run) </td></tr>
<tr id="row_2_10_2_3_2_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_topo_engine.html" target="_self">GTopoEngine</a></td><td class="desc">拓扑排序，并按照拓扑排序的顺序串行执行 </td></tr>
<tr id="row_2_10_2_4_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_10_2_4_" class="arrow" onclick="toggleFolder('2_10_2_4_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_optimizer.html" target="_self">GOptimizer</a></td><td class="desc">GOptimizer是用来干嘛的? </td></tr>
<tr id="row_2_10_2_4_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_max_para_optimizer.html" target="_self">GMaxParaOptimizer</a></td><td class="desc"></td></tr>
<tr id="row_2_10_2_4_1_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_separate_optimizer.html" target="_self">GSeparateOptimizer</a></td><td class="desc">判断两个element是否可以独立运行 </td></tr>
<tr id="row_2_10_2_4_2_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_trim_optimizer.html" target="_self">GTrimOptimizer</a></td><td class="desc"></td></tr>
<tr id="row_2_10_3_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_event_object.html" target="_self">GEventObject</a></td><td class="desc"></td></tr>
<tr id="row_2_10_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_10_4_" class="arrow" onclick="toggleFolder('2_10_4_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message_object.html" target="_self">GMessageObject</a></td><td class="desc">GMessageObject在继承GraphObject的基础上删除了run函数 (<a class="el" href="class_graph_object.html" title="GraphObject = CObject，没有新增或删除任何成员">GraphObject</a> = <a class="el" href="class_c_object.html">CObject</a>) </td></tr>
<tr id="row_2_10_4_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message.html" target="_self">GMessage&lt; T, capacity, &gt;</a></td><td class="desc">基于UAtomicRingBufferQueue队列实现，支持send/recv </td></tr>
<tr id="row_2_10_4_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message_manager.html" target="_self">GMessageManager&lt; T, &gt;</a></td><td class="desc">基于topic，支持send/recv(一发一收)，也支持pub/sub(一发多收) sub端每次订阅特定的topic之前都要先bindTopic生成一个唯一的conn_id_，实际上是绑定到这个conn_id_对应的GMessageObject的消息队列 recv是一发一收则可以直接用topic作为入参 </td></tr>
<tr id="row_2_10_4_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message_manager_singleton.html" target="_self">GMessageManagerSingleton</a></td><td class="desc">默认的GMessageObject使用的参数类型是GMessageParam，是全局参数，用单例管理更合适 </td></tr>
<tr id="row_2_10_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_10_5_" class="arrow" onclick="toggleFolder('2_10_5_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_param_object.html" target="_self">GParamObject</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_10_5_0_" class="arrow" onclick="toggleFolder('2_10_5_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_message_param.html" target="_self">GMessageParam</a></td><td class="desc">GMessageParam作用域为进程，GParam作用域为图(piepline) GPassedParam作用域为结点(GElement/GDaemon/GAspect/GEvent) </td></tr>
<tr id="row_2_10_5_0_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_image_m_param.html" target="_self">ImageMParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_0_1_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_input_m_param.html" target="_self">InputMParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_0_2_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_result_m_param.html" target="_self">ResultMParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_1_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_10_5_1_" class="arrow" onclick="toggleFolder('2_10_5_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_param.html" target="_self">GParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_1_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_d_ann_param.html" target="_self">DAnnParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_1_1_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_detect_result_g_param.html" target="_self">DetectResultGParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_1_2_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_nums_g_param.html" target="_self">NumsGParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_1_3_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_process_g_param.html" target="_self">ProcessGParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_2_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_param_manager.html" target="_self">GParamManager</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_3_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_10_5_3_" class="arrow" onclick="toggleFolder('2_10_5_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_passed_param.html" target="_self">GPassedParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_5_3_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_passed_default_param.html" target="_self">GPassedDefaultParam</a></td><td class="desc"></td></tr>
<tr id="row_2_10_6_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_perf.html" target="_self">GPerf</a></td><td class="desc">Pipeline性能分析，具体做法是通过inject注入统计性能的切面，然后运行pipeline， 接着输出最长路径和整个pipeline的可视化，最后通过recover删除切面恢复原来的pipeline </td></tr>
<tr id="row_2_10_7_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_10_7_" class="arrow" onclick="toggleFolder('2_10_7_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline_object.html" target="_self">GPipelineObject</a></td><td class="desc"></td></tr>
<tr id="row_2_10_7_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline.html" target="_self">GPipeline</a></td><td class="desc"></td></tr>
<tr id="row_2_10_7_1_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline_factory.html" target="_self">GPipelineFactory</a></td><td class="desc"></td></tr>
<tr id="row_2_10_7_2_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_pipeline_manager.html" target="_self">GPipelineManager</a></td><td class="desc"></td></tr>
<tr id="row_2_10_8_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_schedule.html" target="_self">GSchedule</a></td><td class="desc"></td></tr>
<tr id="row_2_10_9_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_10_9_" class="arrow" onclick="toggleFolder('2_10_9_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_stage_object.html" target="_self">GStageObject</a></td><td class="desc"></td></tr>
<tr id="row_2_10_9_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_stage.html" target="_self">GStage</a></td><td class="desc"></td></tr>
<tr id="row_2_10_9_1_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_stage_manager.html" target="_self">GStageManager</a></td><td class="desc"></td></tr>
<tr id="row_2_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_2_11_" class="arrow" onclick="toggleFolder('2_11_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_utils_object.html" target="_self">UtilsObject</a></td><td class="desc">UtilsObject单独继承CObject，run()标记为CGRAPH_NO_SUPPORT </td></tr>
<tr id="row_2_11_0_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_serial_unique_array.html" target="_self">USerialUniqueArray&lt; std::string &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_1_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_singleton.html" target="_self">USingleton&lt; GMessageManager&lt;&gt;, USingletonType::LAZY, false &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_2_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_small_vector.html" target="_self">USmallVector&lt; GElement * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_3_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_11_3_" class="arrow" onclick="toggleFolder('2_11_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_distance_object.html" target="_self">UDistanceObject</a></td><td class="desc"><a class="el" href="class_u_distance_object.html" title="UDistanceObject = UtilsObject.">UDistanceObject</a> = <a class="el" href="class_utils_object.html" title="UtilsObject单独继承CObject，run()标记为CGRAPH_NO_SUPPORT.">UtilsObject</a> </td></tr>
<tr id="row_2_11_3_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_11_3_0_" class="arrow" onclick="toggleFolder('2_11_3_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_distance.html" target="_self">UDistance&lt; TSrc, TSrc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_3_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_cosine_distance.html" target="_self">UCosineDistance&lt; TSrc, TRes &gt;</a></td><td class="desc">计算v1和v2两个向量的cos距离 默认v1和v2的维度相同(dim1 == dim2)且非零 (此处calc实现未做检查，可能出现除零错误) </td></tr>
<tr id="row_2_11_3_0_1_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_euclidean_distance.html" target="_self">UEuclideanDistance&lt; TSrc, TRes, needSqrt &gt;</a></td><td class="desc">计算几何距离(欧氏距离) </td></tr>
<tr id="row_2_11_3_1_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_distance.html" target="_self">UDistance&lt; TSrc, TRes &gt;</a></td><td class="desc">距离计算类的基类，提供calc(计算向量距离)、check(检查向量)、normalize(向量归一化)三个虚函数 其中calc是纯虚函数，派生类必须重写 </td></tr>
<tr id="row_2_11_3_2_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_distance_calculator.html" target="_self">UDistanceCalculator&lt; TSrc, TRes, UDist, needCheck, &gt;</a></td><td class="desc">对UDistance及其派生类UDist的进一步封装 UDist本身也是模板参数，通过另一个模板参数needCheck指定在calc之前是否要check </td></tr>
<tr id="row_2_11_4_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_lru.html" target="_self">ULru&lt; K, V, DefaultCapacity &gt;</a></td><td class="desc">LRU(Least Recently Used)，基于双链表(list)存储 最少被使用的结点放在表尾，最近/最多被使用的结点放在表头 </td></tr>
<tr id="row_2_11_5_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_u_lru_node.html" target="_self">ULruNode&lt; K, V &gt;</a></td><td class="desc">ULru双链表nodes_存储的结点类型 </td></tr>
<tr id="row_2_11_6_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_random.html" target="_self">URandom&lt; T, SEED, TEngine &gt;</a></td><td class="desc">随机数生成类，支持模板入参T(默认CFloat)、SEED(0为完全随机值，其他为固定随机值)、 TEngine为随机数的生成方式(梅森旋转法/线性同余法/滞后Fibonacci/...) generate: 基于std::uniform_real_distribution生成指定T类型、一维或二维、指定个数的均匀分布的随机数存入data generateSession：生成随机session_信息，常用于CDescInfo的成员，作为CDescInfo派生类(GNode/GAdapter/GElement等)的唯一标识 </td></tr>
<tr id="row_2_11_7_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_serial_unique_array.html" target="_self">USerialUniqueArray&lt; T &gt;</a></td><td class="desc">内部基于std::vector存储，每次插入前进行检查，重复则不插入(uniqueAdd)，保证对外表现为一个不重复数组 </td></tr>
<tr id="row_2_11_8_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_singleton.html" target="_self">USingleton&lt; T, type, autoInit &gt;</a></td><td class="desc">支持默认构造一个T类型的对象、封装成单例使用 目前实际上只支持CObject及其派生类作为单例要维护的对象类型，其他类型在init/destroy阶段啥都不做 </td></tr>
<tr id="row_2_11_9_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_small_vector.html" target="_self">USmallVector&lt; T, CAPACITY &gt;</a></td><td class="desc">申请一块T类型的内存，封装为一个轻量级的std::vector使用 (主要为了减少内存占用?)， 内部的迭代器也使用自定义的UIter </td></tr>
<tr id="row_2_11_10_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_2_11_10_" class="arrow" onclick="toggleFolder('2_11_10_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_thread_object.html" target="_self">UThreadObject</a></td><td class="desc"><a class="el" href="class_u_thread_object.html" title="UThreadObject = UtilsObject，将run置为CGRAPH_NO_SUPPORT.">UThreadObject</a> = UtilsObject，将run置为CGRAPH_NO_SUPPORT </td></tr>
<tr id="row_2_11_10_0_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_u_cv_mutex.html" target="_self">UCvMutex</a></td><td class="desc"></td></tr>
<tr id="row_2_11_10_1_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_11_10_1_" class="arrow" onclick="toggleFolder('2_11_10_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_queue_object.html" target="_self">UQueueObject</a></td><td class="desc">UQueueObject单独继承UThreadObject，只在此基础上新增了mutex_和cv_成员 </td></tr>
<tr id="row_2_11_10_1_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_priority_queue.html" target="_self">UAtomicPriorityQueue&lt; UTask &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_10_1_1_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_queue.html" target="_self">UAtomicQueue&lt; UTask &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_10_1_2_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_ring_buffer_queue.html" target="_self">UAtomicRingBufferQueue&lt; T, CGRAPH_DEFAULT_RINGBUFFER_SIZE &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_10_1_3_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_work_stealing_queue.html" target="_self">UWorkStealingQueue&lt; UTask &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_11_10_1_4_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_priority_queue.html" target="_self">UAtomicPriorityQueue&lt; T &gt;</a></td><td class="desc">包含一个优先级队列成员，基于mutex_封装成一个原子的优先级队列，支持原子的tryPop/push/empty </td></tr>
<tr id="row_2_11_10_1_5_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_queue.html" target="_self">UAtomicQueue&lt; T &gt;</a></td><td class="desc">包含一个普通队列成员，基于mutex_封装成一个原子的优先级队列， 支持原子的waitPop/tryPop/popWithTimeout/push/empty 新增ready_flag_用于通知辅助线程快速退出 </td></tr>
<tr id="row_2_11_10_1_6_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_atomic_ring_buffer_queue.html" target="_self">UAtomicRingBufferQueue&lt; T, capacity &gt;</a></td><td class="desc">包含一个基于std::vector的环形队列，基于mutex_实现原子的waitPopWithTimeout/push head_/tail_初始化为0，tail_及tail_之后一直到head_之前的位置记为空 举例：head_为0、tail_为3、capaci_为64的情况下，[3,63]范围内的位置都记为空 </td></tr>
<tr id="row_2_11_10_1_7_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_lock_free_ring_buffer_queue.html" target="_self">ULockFreeRingBufferQueue&lt; T, CAPACITY &gt;</a></td><td class="desc">环形队列基于std::vector存储，head_和tail_通过std::atomic封装 号称是无锁的，但是从代码看起来push/tryPop操作并不能解决多线程的竞态条件问题，线程安全性存疑？ </td></tr>
<tr id="row_2_11_10_1_8_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_work_stealing_queue.html" target="_self">UWorkStealingQueue&lt; T &gt;</a></td><td class="desc">工作窃取队列，实现为双端队列(deque_)； push在队尾发生，可以一次性写入一个或多个任务，也支持tryPush和带锁的push； pop在队头发生，可以一次性拿出一个或多个任务，也支持tryPop； trySteal在队尾发生，可以一次性窃取一个或多个任务； </td></tr>
<tr id="row_2_11_10_2_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_semaphore.html" target="_self">USemaphore</a></td><td class="desc">基于mutex_/cv_和int计数器cnt_封装的信号量 </td></tr>
<tr id="row_2_11_10_3_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_spin_lock.html" target="_self">USpinLock</a></td><td class="desc">基于std::atomic_flag实现的用户态自旋锁，std::atomic_flag只有true/false两种状态； USpinLock提供以下三个方法：lock为忙等，tryLock为单次尝试，unlock为解锁； (基于std::atomic_flag实现的用户态自旋锁是一种采用的做法，) </td></tr>
<tr id="row_2_11_10_4_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_task_group.html" target="_self">UTaskGroup</a></td><td class="desc">注意，并非基于UTask，实际维护的是CGRAPH_DEFAULT_FUNCTION类型的函数数组(std::vector) 支持addTask将更多的函数加入task_arr_数组，支持指定任务组最大执行耗时ttl 以及对task_arr_数组内的全部函数执行完成(即这个UTaskGroup执行完成)指定后处理接口setOnFinished </td></tr>
<tr id="row_2_11_10_5_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_2_11_10_5_" class="arrow" onclick="toggleFolder('2_11_10_5_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_thread_base.html" target="_self">UThreadBase</a></td><td class="desc">线程池中实际使用的线程的基类，有以下关键成员： <a class="el" href="class_u_atomic_queue.html">UAtomicQueue&lt;UTask&gt;</a>* pool_task_queue_：存储当前线程待执行的普通任务； <a class="el" href="class_u_atomic_priority_queue.html">UAtomicPriorityQueue&lt;UTask&gt;</a>* pool_priority_task_queue_：优先级队列的任务，仅辅助线程可以执行； CInt type_：表明当前线程是普通线程还是辅助线程 UThreadPoolConfigPtr config_：当前线程所属的线程池的配置 std::thread thread_：标准线程对象，实际执行UTask任务的载体 </td></tr>
<tr id="row_2_11_10_5_0_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_thread_primary.html" target="_self">UThreadPrimary</a></td><td class="desc">主线程类，核心成员是primary_queue_和secondary_queue_ 自身准备执行任务时，优先从primary_queue_取，其次从secondary_queue_取 自身准备窃取任务时，优先从secondary_queue_，其次从primary_queue_取 这样设计的好处是A线程的执行和B线程从A线程窃取这两个异步事件发生竞争的可能性大大减小，从而提高性能 主线程所属的主线程池pool_threads_的指针也记录在每个主线程对象里面，在窃取相邻线程任务、安全检查等会用到 </td></tr>
<tr id="row_2_11_10_5_1_" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_thread_secondary.html" target="_self">UThreadSecondary</a></td><td class="desc">和主线程UThreadPrimary不同，辅助线程没有第一第二任务队列的概念，因为辅助线程不允许窃取， 而是直接从普通任务队列(pool_task_queue_)和优先级任务队列(pool_priority_task_queue_)取任务 当然：主线程不会从优先级任务队列(pool_priority_task_queue_)取任务， 这个任务队列存储的一般是长时间任务，是辅助线程专用的 </td></tr>
<tr id="row_2_11_10_6_" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_thread_pool.html" target="_self">UThreadPool</a></td><td class="desc">线程池，包含主线程池、辅助线程池、普通任务队列、优先级任务队列、线程池配置、监控线程等 </td></tr>
<tr id="row_2_11_11_"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_time_counter.html" target="_self">UTimeCounter</a></td><td class="desc">基于std::chrono::steady_clock::time_point封装的计时器； 构造的同时记录时间戳，析构的同时打印从构造到析构的间隔span </td></tr>
<tr id="row_2_11_12_" class="even"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_timer.html" target="_self">UTimer</a></td><td class="desc">定周期执行任务的定时器，不需要在初始化的时候传入任务，只需要start的时候传入即可； start还可以指定定时器的执行周期interval、每次task执行完成后可以更改下一次执行周期的modify接口； 定时器的结束通过is_stop_这个std::atomic_bool值和std::condition_variable实现， start接口is_stop_ exchange为false，对exchange之前的值做检查也保证了不会重复start stop接口将is_stop_设置为true，并通知正在cv_上等待的start直接退出，接着等待std::future对象返回 </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_c_s_t_a_t_u_s.html" target="_self">CSTATUS</a></td><td class="desc"></td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_4_" class="arrow" onclick="toggleFolder('4_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_c_struct.html" target="_self">CStruct</a></td><td class="desc"></td></tr>
<tr id="row_4_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_g_element_relation.html" target="_self">GElementRelation</a></td><td class="desc">CStruct的派生类，POD，维护GElement的前驱后继结点和所属关系 </td></tr>
<tr id="row_4_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_g_element_sorter.html" target="_self">GElementSorter</a></td><td class="desc"></td></tr>
<tr id="row_4_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_g_node_info.html" target="_self">GNodeInfo</a></td><td class="desc">功能节点信息 创建GCluster和GRegion的中的GNode的时候，使用到的信息 创建GCluster的时候，dependence为空 创建GRegion的时候，dependence不为空。若为空，则表示可直接执行 </td></tr>
<tr id="row_4_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_g_perf_info.html" target="_self">GPerfInfo</a></td><td class="desc">性能分析数据，目前只支持耗时和最长连路分析 </td></tr>
<tr id="row_4_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_metrics.html" target="_self">UMetrics</a></td><td class="desc">CGraph自带的线程池性能指标统计，主要包含 本地任务队列pop、全局任务队列pop、工作窃取、任务push、轻量级等待(yield)、深度等待(cv.wait)等相关的指标 </td></tr>
<tr id="row_4_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_task.html" target="_self">UTask</a></td><td class="desc">基于内嵌类TaskBased和TaskDerided，将传入的func完美转发成TaskDerided的func_成员； TaskDerided是UTask的impl_成员，运行UTask实际上就是调用impl_-&gt;run也就是调用func_() </td></tr>
<tr id="row_4_6_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_u_thread_pool_config.html" target="_self">UThreadPoolConfig</a></td><td class="desc">具体值含义，参考UThreadPoolDefine.h文件；支持配置以下项目： default_thread_size_: 默认开启主线程个数 secondary_thread_size_: 默认开启辅助线程个数 max_thread_size_: 最大线程个数 max_task_steal_range_: 盗取机制相邻范围 max_local_batch_size_: 批量执行本地任务最大值 max_pool_batch_size_: 批量执行通用任务最大值 max_steal_batch_size_: 批量盗取任务最大值 primary_thread_busy_epoch_: 主线程进入wait状态的轮数，数值越大，理论性能越高，但空转可能性也越大 primary_thread_empty_interval_: 主线程进入休眠状态的默认时间 secondary_thread_ttl_: 辅助线程ttl，单位为s monitor_span_: 监控线程执行间隔，单位为s queue_emtpy_interval_: 队列为空时，等待的时间。仅针对辅助线程，单位为ms primary_thread_policy_: 主线程调度策略 secondary_thread_policy_: 辅助线程调度策略 primary_thread_priority_: 主线程调度优先级（取值范围0~99，配合调度策略一起使用，不建议不了解相关内容的童鞋做修改） secondary_thread_priority_: 辅助线程调度优先级（同上） bind_cpu_enable_: 是否开启绑定cpu模式（仅针对主线程） batch_task_enable_: 是否开启批量任务功能 monitor_enable_: 是否开启监控程序 </td></tr>
<tr id="row_5_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_5_" class="arrow" onclick="toggleFolder('5_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>std::exception</b></td><td class="desc"></td></tr>
<tr id="row_5_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_c_e_x_c_e_p_t_i_o_n.html" target="_self">CEXCEPTION</a></td><td class="desc"></td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_6_" class="arrow" onclick="toggleFolder('6_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>CGraph::GAspect</b></td><td class="desc"></td></tr>
<tr id="row_6_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_test_material_add1_g_aspect.html" target="_self">TestMaterialAdd1GAspect</a></td><td class="desc"></td></tr>
<tr id="row_7_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_7_" class="arrow" onclick="toggleFolder('7_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>CGraph::GMessageParam</b></td><td class="desc"></td></tr>
<tr id="row_7_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_test_g_message_param.html" target="_self">TestGMessageParam</a></td><td class="desc"></td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_8_" class="arrow" onclick="toggleFolder('8_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>CGraph::GNode</b></td><td class="desc"></td></tr>
<tr id="row_8_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_test_add1_g_node.html" target="_self">TestAdd1GNode</a></td><td class="desc"></td></tr>
<tr id="row_8_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_test_recv_message_g_node.html" target="_self">TestRecvMessageGNode</a></td><td class="desc"></td></tr>
<tr id="row_8_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_test_return_error_g_node.html" target="_self">TestReturnErrorGNode</a></td><td class="desc"></td></tr>
<tr id="row_9_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_9_" class="arrow" onclick="toggleFolder('9_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_u_task_1_1_task_based.html" target="_self">UTask::TaskBased</a></td><td class="desc"></td></tr>
<tr id="row_9_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="struct_u_task_1_1_task_derided.html" target="_self">UTask::TaskDerided&lt; F, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="class_u_small_vector_1_1_u_iter.html" target="_self">USmallVector&lt; T, CAPACITY &gt;::UIter</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
